[gd_scene load_steps=3 format=3 uid="uid://rboobukjipe7"]

[ext_resource type="PackedScene" uid="uid://cyl1d6reu3mk4" path="res://Nodes/GUI/DirectorySelector.tscn" id="1_daj5t"]

[sub_resource type="GDScript" id="GDScript_dhanr"]
script/source = "extends \"res://Tasks/ScriptTask.gd\"

@onready var input_path: Control = %InputPath
@onready var output_path: Control = %OutputPath
@onready var header: LineEdit = %Header

func _get_task_name() -> String:
	return \"Trim MD File\"

func _get_task_info() -> PackedStringArray:
	return [
		\"Trims the given .md file to include only the given header.\",
		\"Input Path|Original markdown file.\",
		\"Output Path|Trimmed markdown filepath.\",
		\"Header|Header to trim it to, excluding everything else. The trimmed file will include only text and subheaders under the first header that begins with this string.\",
	]

func _get_execute_string() -> String:
	return \"Trim markdown file at %s to %s, including only %s\" % [input_path.text, output_path.text, header.text]

static func _initialize_project() -> void:
	pass

static func _begin_project_scan() -> void:
	pass

static func _process_file(path: String) -> void:
	pass

static func _end_project_scan() -> void:
	pass

func _initialize() -> void:
	defaults[\"input_path\"] = \"\"
	defaults[\"output_path\"] = \"\"
	defaults[\"header\"] = \"\"

func _prevalidate() -> bool:
	if input_path.text.is_empty():
		error_message = \"No input path given.\"
	elif output_path.text.is_empty():
		error_message = \"No output path given.\"
	elif header.text.is_empty():
		error_message = \"No header given.\"
	elif not header.text.begins_with(\"#\"):
		error_message = \"Invalid markdown header.\"

	return error_message.is_empty()

func _validate() -> bool:
	if not FileAccess.file_exists(Data.resolve_path(input_path.text)):
		error_message = \"Input path does not point to a file.\"

	return error_message.is_empty()

func _get_arguments() -> PackedStringArray:
	var ret := super()

	ret.append(Data.resolve_path(input_path.text))
	ret.append(Data.resolve_path(output_path.text))
	ret.append(header.text)

	return ret

func _prepare() -> void:
	pass

func _cleanup() -> void:
	pass

func _load() -> void:
	input_path.text = data[\"input_path\"]
	output_path.text = data[\"output_path\"]
	header.text = data[\"header\"]

func _store() -> void:
	data[\"input_path\"] = input_path.text
	data[\"output_path\"] = output_path.text
	data[\"header\"] = header.text
"

[node name="TrimMarkdown" type="GridContainer"]
custom_minimum_size = Vector2(400, 0)
offset_right = 400.0
offset_bottom = 66.0
columns = 2
script = SubResource("GDScript_dhanr")
script_name = "TrimMarkdown.gd"

[node name="Label" type="Label" parent="."]
custom_minimum_size = Vector2(150, 0)
layout_mode = 2
size_flags_horizontal = 8
text = "Input Path"
horizontal_alignment = 2

[node name="InputPath" parent="." instance=ExtResource("1_daj5t")]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
mode = 1
scope = 1
missing_mode = 1
filters = PackedStringArray("*.md")

[node name="Label2" type="Label" parent="."]
custom_minimum_size = Vector2(150, 0)
layout_mode = 2
size_flags_horizontal = 8
text = "Output Path"
horizontal_alignment = 2

[node name="OutputPath" parent="." instance=ExtResource("1_daj5t")]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
mode = 2
scope = 1
filters = PackedStringArray("*.md")

[node name="Label3" type="Label" parent="."]
auto_translate_mode = 1
layout_mode = 2
size_flags_horizontal = 8
text = "Header"
horizontal_alignment = 2

[node name="Header" type="LineEdit" parent="."]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
placeholder_text = "## Header to include"
